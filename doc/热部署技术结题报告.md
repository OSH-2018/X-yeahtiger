# 热替换技术结题报告

## 摘要

热替换技术，又名 Tiger Fix，是一个在程序运行时动态更改其业务逻辑的项目。我们组员经过三个月的努力，基本实现了在中期检查报告中提出的设想，设计了一套可行的方案，用编程验证了该方案，并且设计了一套用户友好的界面便于用户安装和使用。

## 用户接口

tfix 主要分为两大子模块: gen 和 fix，而用户要进行热修复，需要进行以下三个步骤：

1. 对于用户需要修改的程序（下称目标程序）片段（本项目目前支持以函数为单位的修改），用户将需要修改的代码写在文件里，直接编译生成目标代码(.o文件)
2. 调用 tfix gen 模块。tfix gen 模块在接收以上目标代码的同时，还会分析目标程序的可执行文件的信息，读取目标程序基址，生成 tfix fix 所需的补丁中间文件(.tfp文件)。
3. 用 root 权限执行 tfix fix 模块。它接收中间文件(.tfp文件)和目标程序的进程 id (pid)，调用了 ptrace  工具来中断进程，修改函数入口处代码，并跳转到新添加的函数。

## 背景知识

### ELF 文件格式

##### 1. ELF 文件介绍

ELF 文件是可执行与可链接格式的英文缩写(英语：Executable and Linkable Format)，这是一种在 Unix 系统用于可执行文件、目标代码、共享库和核心转储(Core Dump)的标准文件格式。

##### 2. ELF 文件分类

###### i. 可重定位的对象文件(Relocatable File)

这是由汇编器汇编生成的 .o 文件。后面的链接器拿它作为输入，经链接处理后，生成一个可执行的对象文件 (Executable File) 或者一个可被共享的对象文件(Shared Object File)

###### ii. 可执行的对象文件(Executable File)

很常见，如文本编辑器vi等等。可执行的脚本(如shell脚本)不是 Executable Object File，它们只是文本文件。

###### iii. 可被共享的对象文件(Shared Object File)

这就是所谓的动态库文件，也即 .so 文件。动态库在发挥作用的过程中，必须经过两个步骤：

1. 链接编辑器拿它和其他可重定位对象文件(Relocatable Object File)以及共享对象文件(Shared Object File)作为输入，经链接处理后，生成另外的共享对象文件或者可执行文件。
2. 运行时，动态链接器(Dynamic Linker)拿它和一个Executable File以及另外一些 Shared Object File 来一起处理，在Linux系统里面创建一个进程映像。

##### 3. ELF 文件组成

ELF 文件大都包含 ELF 头部、程序头部表、节区或段、节区头部表。 ELF 头部用来描述整个文件的组织。节区部分包含链接视图的指令、数据、符号表、重定位信息等。程序头部表告诉系统如何创建进程映像。节区头部表包含了描述文件节区的信息，如名称、大小。

![ELF 文件结构](https://img-blog.csdn.net/20160521110158483)

- 组成不同的可重定位文件（.o 文件）参与可执行文件或者可被共享的对象文件的链接构建。不需要程序头部表。必须包含节区头部表。以节为单位。
- 组成可执行文件或者可被共享的对象文件（.so文件）在运行时内存中进程映像的构建。 必须具有程序头部表。可以无节区头部表。以段为单位。

| 可重定位文件       | 可执行或可被共享的对象文件 |
| ------------------ | -------------------------- |
| ELF头部            | ELF头部                    |
| 程序头部表（可无） | 程序头部表（必须）         |
| 很多节区           | 很多段                     |
| 节区头部表（必须） | 节区头部表（可无）         |

### 动态链接过程

一个程序要想装入内存运行必然要先经过编译、链接和装入这三个阶段。人们考虑将如果两个程序用到相同的函数库，那么理想的情况是系统中只保存一份函数库的拷贝（无论是在内存中还是在硬盘上），于是人们想到了动态链接的方法来实现函数库的复用：动态链接使得两个进程在内存中通过将地址映射到相同的 .o 文件实现对其的共享。动态链接的这一特性对于库的升级（比如错误的修正）是至关重要的。当一个库升级到一个新版本时，所有用到这个库的程序将自动使用新的版本；如果不使用动态链接技术，那么所有这些程序都需要被重新链接才能得以访问新版的库。这样的系统被称作共享库系统。我们在热部署的实现中正好利用这个特性来实现我们的目的，即如果我们要修改一个函数，我们将新的函数存储在动态链接库中，然后将旧的函数名重新链接（这是个动态链接过程）到在动态链接库中的函数地址。

![动态链接过程](./pic/动态链接过程.jpg)

### GOT - Global Offset Table

ELF 共享库使用 PIC 技术使代码和数据的引用与地址无关，程序可以被加载到地址空间的任意位置。PIC 在代码中的跳转和分支指令只使用相对地址。PIC 在 ELF 中建立一个存放所有全局变量指针的全局偏移量表 GOT

- 对于模块外部引用的全局变量和全局函数，GOT 表的表项内容为变量或函数的地址，这样通过这个地址就可以间接访问。
- 对于本模块内的静态变量和静态函数，用相对于GOT 表的首地址的偏移量来引用，因为模块内的静态变量和静态函数与 GOT 的距离是固定的，且这段距离大小在链接阶段就可知。因此PIC 使用 GOT 来引用变量和函数的绝对地址，把位置独立的引用重定向到绝对位置，与程序被加载到何种地址空间无关。

对于 PIC 代码，代码段内不存在重定位项，实际的重定位项只是在数据段的 GOT 表内。



### PLT - Procedure Linkage Table

过程链接表 PLT 用于把位置独立的函数调用重定向到绝对位置。通过 PLT 动态链接的程序支持惰性绑定模式。每个动态链接的程序和共享库都有一个 PLT，PLT 表的每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。程序对某个函数的访问都被调整为对 PLT 入口的访问，每个 PLT 入口项对应一个 GOT 项，执行函数实际上就是跳转到相应 GOT 项存储的地址。



## 原理简要介绍

tfix 首先调用 ptrace 将函数中断，然后找到原函数入口地址，将其开头的字节替换为以下汇编代码：

```assembly
push rax 						   	;(暂时保存 rax 寄存器的值)

mov 新函数入口地址 rax	 				;（将新函数地址存入 rax 寄存器)

jmp rax								;（跳转到新函数）

```

同时，我们以调用动态链接库 (dlopen) 的形式加载用户提供的目标文件。（注意到 dev.h 头文件通过宏定义的方式使得用户的提供的新函数入口处第一条指令为为`pop rax`，这样能恢复 rax 寄存器）

当完成这些步骤后，将控制权返回给程序，程序继续执行。

这样每当该被修复的函数被调用时，PC指针会先跳转到旧函数地址，然后通过这些添加进来的指令跳转到新的函数地址，完成了函数的替换。这样，热修复就完成了。



## 具体技术实现

下面介绍以上三个步骤的技术上的具体实现：

### (1) 用户对源码的变动

用户原项目代码需要包含头文件 #include <tigerfix/def.h>，用于修复原代码的补丁代码需要包含头文件 #include <tigerfix/dev.h>

同时，用户需要将补丁代码中的所有外部符号引用（包括外部变量和外部函数调用）用 extern 声明。

其中，dev.h 头文件用宏定义的方式来声明一个外部符号 fix_func （其中func为宏接收的参数，即需要修复的函数名称）。该符号下接两条汇编指令：

1. pop rax （用于将之前受到影响的 rax 寄存器恢复现场）
2. 跳转到新函数地址的跳转指令

同时，编译源码时候将外部符号指向的地址人为规定为魔数 0xc0ffee（该魔数起到了占位符的作用）

### (2) 补丁中间文件的生成

我们需要第一步中由用户生成的目标代码，和欲修复进程的可执行文件这两个文件，通过组合这两个文件来生成补丁的中间文件。

如何生成目标代码已经涉及过了，下面来介绍我们需要读取可执行文件中的哪些信息。

主要有以下信息：

1. 可执行文件的寻址方式（是相对寻址还是绝对寻址）
2. 旧函数的地址 和 新函数的地址
3. 外部变量（如全局变量）的地址 和 外部变量在 GOT 表中的项
4. 外部函数的地址 和 外部函数在 GOT 表中的项

### (3) 修复

修复过程主要由两个进程主导：

1. fix.py 
2. libtfix.so

#### fix.py

1. 从 /proc/$(pid)/maps 中读取欲修改进程的基地址。
2. 使用 ptrace 追踪待更新的进程，并在下一次系统调用结束的时候暂停欲修改进程。
3. 暂存所有寄存器的值
4. 将欲修改进程的 rip 寄存器（PC）修改为 libtfix.so 中的 do_fix_entry 地址（该地址是执行修改进程一系列操作的函数的入口地址）
5. 将补丁中间文件的文件地址和欲修改进程的基地址压栈，同时将栈指针放到 rdi 参数寄存器中
6. 此时，让进程继续执行

当进程继续执行时，会跳转到 libtfix.so 的地址，开始执行 do_fix_entry 的内容

#### libtfix.so

1. 通过参数寄存器，读取栈指针，并通过栈指针读取中间文件的文件地址和进程的基地址。
2. 提取出中间文件的信息和补丁目标文件
3. 通过 dlopen 将补丁目标文件加载到内存中
4. 修改补丁目标文件的GOT

#### 修改补丁目标文件GOT的步骤

1. 寻找GOT中所有值为 0xc0ffee 的项（意味着这些项将被修改）
2. 读取欲修改进程的符号表，参考符号表来修改补丁目标文件的GOT



## 讨论

## Acknowledgement

## Reference

